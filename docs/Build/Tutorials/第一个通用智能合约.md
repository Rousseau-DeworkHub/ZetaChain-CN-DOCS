# 第一个通用智能合约

构建你的第一个通用智能合约

在本教程中，你将在 ZetaChain 上创建一个简单的通用应用。当该应用收到来自Connected Chains 的跨链调用时，它将发出一个事件。通过本教程，你将了解：

- 构建一个基础的通用应用
- 将其部署到 ZetaChain 本地网络上
- 使用已连接链上的 Gateway 来调用你的通用程序

# 必要条件

在开始之前，请确保你已完成以下教程：

- [通用程序简介](https://www.zetachain.com/docs/start/app/)
- [ZetaChain 入门](https://www.zetachain.com/docs/developers/tutorials/intro)

# 配置你的环境

要启动你的 ZetaChain 项目，请首先使用 ZetaChain CLI（命令行界面） 初始化一个新项目。这将建立基础的项目结构。

```shell
npx zetachain@latest new --project hello
cd hello
yarn
forge soldeer update
```

首先，`npx zetachain@latest new --project hello`使用 npx 执行最新版本的 zetachain 包，创建一个名为 `hello`的新项目目录。

然后，`cd hello`将你导航到新创建的项目目录中。

接下来，`yarn`（如果你更喜欢 npm，则使用 `npm install`）会安装 `package.json`文件中定义的所有必要项目依赖项。这确保你的开发环境拥有所有必需的库和工具。

最后，`forge soldeer update`会同步和更新由 Foundry 的 Soldeer 管理的你的 Solidity 依赖项，确保你的合约是针对外部库的最新兼容版本构建的。

# 通用智能合约

一个通用程序是一个实现了 `UniversalContract`接口的合约。

**contracts/Universal.sol**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import "@zetachain/protocol-contracts/contracts/zevm/GatewayZEVM.sol";

contract Universal is UniversalContract {
    GatewayZEVM public immutable gateway;

    event HelloEvent(string, string);

    error Unauthorized();

    modifier onlyGateway() {
        if (msg.sender != address(gateway)) revert Unauthorized();
        _;
    }

    constructor(address payable gatewayAddress) {
        gateway = GatewayZEVM(gatewayAddress);
    }

    function onCall(
        MessageContext calldata context,
        address zrc20,
        uint256 amount,
        bytes calldata message
    ) external override onlyGateway {
        string memory name = abi.decode(message, (string));
        emit HelloEvent("Hello: ", name);
    }
}
```

构造函数接收 ZetaChain 的 Gateway 地址并将其存储在一个状态变量中。Gateway 用于进行出站合约调用和代币提现。

一个通用智能合约必须实现 `onCall`函数。当合约通过 Gateway 收到来自已连接链的调用时，会触发此函数。该函数处理传入的数据，包括：

- `context`：一个包含以下信息的 `MessageContext`结构体： 
  - `chainID`：发起跨链调用的已连接链的链 ID。 
  - `sender`：在已连接链上调用 Gateway 的地址（EOA 或合约）。 
  - `origin`：已弃用。

- `zrc20`：代表来自源链资产的 ZRC-20 代币的地址。
- `amount`：转移的代币数量。
- `message`：编码的载荷数据。

在此示例中，`onCall`将 `message`解码为一个字符串并触发一个事件。

`onCall`只应被 Gateway 调用，以确保它仅作为对已连接链上调用的响应而被触发，并且你可以信任函数参数的值。

# 选项1：部署在本地网络

本节将指导你在 ZetaChain [本地网络](https://www.zetachain.com/docs/reference/localnet)上部署通用智能合约并与之交互。使用本地网络提供了一个安全、隔离的测试和开发环境，无需支付真实的网络费用或影响线上部署。

> 为了获得最佳工作流程，强烈建议使用分屏终端或两个独立的终端窗口。这允许你在一个终端中持续运行本地网络，同时在另一个终端中执行命令并与你的项目交互，从而简化你的开发过程。

第一步是启动你的本地 ZetaChain 网络。这将在你的机器上模拟一个完整的 ZetaChain 环境。

- 打开一个专用于运行 本地网络 的新终端窗口。

- 在此终端中，执行以下命令：

```shell
npx zetachain localnet start
```

此命令将启动本地 ZetaChain 网络。所有组件启动可能需要一些时间。当你在终端中看到一个格式化的表格打印出来时，就表示本地网络已准备就绪。该表格将显示不同链的关键合约地址，包括 ZETACHAIN、ETHEREUM 和 BNB。这些地址对于与你的本地网络交互至关重要。

> **不要关闭此终端！** 在后续步骤中保持本地网络持续运行至关重要。关闭此终端将关闭你的本地网络，你需要重新启动才能继续。

一旦本地网络处于活动状态，下一步就是编译你的智能合约。此过程将你可读的 Solidity 代码转换为以太坊虚拟机（EVN）可以理解和执行的字节码。

- 打开第二个终端窗口（或拆分你现有的终端）专用于你的项目命令。

- 导航到你的项目目录（如果你还没有进入该目录）。

- 运行以下命令：

```shell
forge build
```

`forge build`命令告诉 Foundry 编译你项目中的所有 Solidity 智能合约，确保你使用的是最新编译的版本。成功编译将为你的合约生成字节码。

要部署合约并与 ZetaChain本地网络上的合约交互，你需要 ZetaChain Gateway 合约的地址。该合约是 ZetaChain 上跨链交互的入口点。

- 当你的本地网络仍在专用终端中运行时，请仔细查看其输出。

- 从本地网络终端输出中复制 Gateway 合约地址。查找 ZETACHAIN 部分下标记为 `gateway`的行。它通常以类似以下的格式出现：

```shell
| gateway '0x2279B7A0a67DB372996a5FaB50D91eAA73d2eBe6' |
```

仅复制十六进制地址（例如，`0x2279B7A0a67DB372996a5FaB50D91eAA73d2eBe6`）。不要包括单引号或任何其他周围的文本。

或者运行以下命令以编程方式获取 Gateway 地址：

```shell
GATEWAY_ZETACHAIN=$(jq -r '.["31337"].contracts[] | select(.contractType == "gateway") | .address' ~/.zetachain/localnet/registry.json) && echo $GATEWAY_ZETACHAIN
```

获取在已连接链上预存有代币的私钥：

```shell
PRIVATE_KEY=$(jq -r '.private_keys[0]' ~/.zetachain/localnet/anvil.json) && echo $PRIVATE_KEY
```

部署通用智能合约并在构造函数中提供 Gateway 地址：

```shell
UNIVERSAL=$(forge create Universal \
  --rpc-url http://localhost:8545 \
  --private-key $PRIVATE_KEY \
  --evm-version paris \
  --broadcast \
  --json \
  --constructor-args $GATEWAY_ZETACHAIN | jq -r .deployedTo) && echo $UNIVERSAL
```

## 调用通用程序

要从已连接的 EVM 链调用部署在 ZetaChain 上的通用程序，需要向该已连接链上的 Gateway 合约发送一笔交易。

获取已连接链的 Gateway 地址：

```shell
GATEWAY_EVM=$(jq -r '.["11155112"].contracts[] | select(.contractType == "gateway") | .address' ~/.zetachain/localnet/registry.json) && echo $GATEWAY_EVM
```

或者你可以直接从 本地网络 启动时打印的表格中复制 Gateway 地址。

在已连接链的 Gateway 上执行`call`方法，向部署在 ZetaChain 上的通用智能合约发送一条消息。

```shell
npx zetachain evm call \
  --rpc http://localhost:8545 \
  --gateway $GATEWAY_EVM \
  --receiver $UNIVERSAL \
  --private-key $PRIVATE_KEY \
  --types string \
  --values hello
```

交易处理完成后，你将在 本地网络 终端中看到一条 `[ZetaChain]: Event from onCall`日志。

# 选项2：部署在测试网

## 钱包与环境设置

要与 ZetaChain 上的智能合约交互并部署它们，你需要一个 EVM 兼容的私钥以及一种在项目环境中安全管理它的方法。

EVM 兼容的私钥是签署交易的基础，这是在 ZetaChain EVM 上部署智能合约和与智能合约交互所必需的。你有几个可靠的选择来生成此密钥：

- 使用 MetaMask：MetaMask 是一个流行的浏览器扩展，用作加密货币钱包和去中心化应用程序的网关。你可以在 MetaMask 中创建一个新钱包，它会为你生成一个私钥。请务必安全地备份你的助记词。
- 使用 cast CLI：为了通过命令行快速直接地生成，你可以使用以下命令：

```shell
PRIVATE_KEY=$(cast wallet new --json | jq -r '.[0].private_key') && echo $PRIVATE_KEY
```

此命令利用 Foundry 的 `cast`实用程序生成一个新的 EVM 钱包。`--json`标志以 JSON 格式输出钱包详细信息，`jq`查询提取 `private_key`字段，将其打印为 64 个字符的十六进制字符串。

## 在 ZetaChain 上部署合约

使用[合约地址页面](https://www.zetachain.com/docs/reference/network/contracts/)中的 Gateway 地址将合约部署到 ZetaChain 的测试网：

```shell
UNIVERSAL=$(forge create Universal \
  --rpc-url https://zetachain-athens-evm.blockpi.network/v1/rpc/public \
  --private-key $PRIVATE_KEY \
  --broadcast \
  --json \
  --constructor-args 0x6c533f7fe93fae114d0954697069df33c9b74fd7 | jq -r .deployedTo)
```

## 从 Base 调用通用智能合约

本节详细介绍了从已连接的测试网（特别是 Base Sepolia）发起跨链交易，以与部署在 ZetaChain 上的通用程序lication 交互的过程。该过程涉及两个主要步骤：进行初始交易，然后跟踪其跨链状态。

要调用 ZetaChain 上的通用程序，必须向 Base Sepolia 上的 Gateway 发送一笔交易。这是通过使用 `npx zetachain evm call`命令实现的，该命令促进了 EVM 交易的执行。

命令结构如下：

```shell
npx zetachain evm call \
  --chain-id 84532 \
  --receiver $UNIVERSAL \
  --private-key $PRIVATE_KEY \
  --types string \
  --values hello
```

**参数说明**：

- `--chain-id 84532`：这指定了交易源网络 Base Sepolia 的链 ID。
- `--receiver $UNIVERSAL`：此参数指定交易意图与之交互的 ZetaChain 上通用智能合约的地址。`$UNIVERSAL`变量应替换为实际的合约地址。
- `--private-key $PRIVATE_KEY`：这是与 Base Sepolia 上发送钱包关联的私钥。它对于签署交易至关重要。`$PRIVATE_KEY`变量必须替换为实际的私钥。
- `--types string`：这指示所发送值的数据类型。在本例中，它是一个字符串。
- `--values hello`：这是传递给通用程序lication 的实际值。此处，字符串 "hello" 作为消息发送到 ZetaChain 上的 通用智能合约。

成功执行此命令后，会生成一个交易哈希，确认交易已在 Base Sepolia 上启动。

```shell
Transaction hash: 0x89308870b0863c5ae48dc783059277cbcf4296b1b343413ac543418262a4ccbc
```

你可以在 Base Sepolia 区块浏览器上验证交易：

https://sepolia.basescan.org/tx/0x89308870b0863c5ae48dc783059277cbcf4296b1b343413ac543418262a4ccbc

## 跟踪跨链交易状态

在 Base Sepolia 上启动交易后，ZetaChain 的协议会促进其跨链传输并在目标链（ZetaChain）上执行。要监控此跨链交易的状态，使用 `npx zetachain query cctx`命令，该命令提供交易过程的实时更新。

跟踪命令是：

```shell
npx zetachain query cctx --hash 0x89308870b0863c5ae48dc783059277cbcf4296b1b343413ac543418262a4ccbc
```

- `--hash 0x89308870b0863c5ae48dc783059277cbcf4296b1b343413ac543418262a4ccbc`：这是从 Base Sepolia 上的初始交易获取的交易哈希。

**示例输出和解释**：

```shell
84532 → 7001 ✅ OutboundMined
CCTX: 0x56f9bc09dc646b13aa713b56348e8a53ea39759146afad61e66973791b752e3b
Tx Hash: 0x89308870b0863c5ae48dc783059277cbcf4296b1b343413ac543418262a4ccbc (on chain 84532)
Tx Hash: 0x34edd96c8a7b2bd9d530de0e49bb5e8625204a77b77cc79133814e1814f79ebc (on chain 7001)
Sender: 0x4955a3F38ff86ae92A914445099caa8eA2B9bA32
Receiver: 0xFeb4F33d424D6685104624d985095dacab567151
Message: 0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000568656c6c6f000000000000000000000000000000000000000000000000000000
```

**输出中的关键信息**：

- `84532 → 7001`：这清楚地表明了跨链流向，从 Base Sepolia（链 ID 84532）到 ZetaChain（链 ID 7001）。`✅`符号表示跨链交易的成功出块挖掘。
- `OutboundMined CCTX: 0x56f9bc09dc646b13aa713b56348e8a53ea39759146afad61e66973791b752e3b`：这是 ZetaChain 上跨链交易的哈希值，代表此特定跨链操作的内部标识符。
- `Tx Hash: 0x89308870b0863c5ae48dc783059277cbcf4296b1b343413ac543418262a4ccbc (on chain 84532)`：这确认了源链（Base Sepolia）上的原始交易哈希。
- `Tx Hash: 0x34edd96c8a7b2bd9d530de0e49bb5e8625204a77b77cc79133814e1814f79ebc (on chain 7001)`：这是在 ZetaChain 上执行的交易哈希，表明通用程序lication 已在目标链上被成功调用。
- `Sender: 0x4955a3F38ff86ae92A914445099caa8eA2B9bA32`：发起链上发送者的地址。
- `Receiver: 0xFeb4F33d424D6685104624d985095dacab567151`：ZetaChain 上接收者合约的地址，在此上下文中即通用程序lication。
- `Message: 0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000568656c6c6f000000000000000000000000000000000000000000000000000000`